Задание №1
from collections import namedtuple
from statistics import mean

New_Company = namedtuple('New_Company', 'name profit_list avg')

lst = []
for i in range(int(input('Введите количество компани '))):
    arg = input('Введите в строку имя и поквартальную прибыль через пробел:\n').split()
    lst.append(New_Company(arg[0], arg[1:], mean(map(int, arg[1:3]))))

avg = mean([i.avg for i in lst])

for i in lst:
    print(f'Компания: {i.name} \t\tСредняя прибыль за год: {i.avg}')

print('_' * 70, '\n')

print('Компании с прибылью меньше средней:')
for i in lst:
    if i.avg < avg:
        print(i.name)

print('Компании с прибылью больше средней:')
for i in lst:
    if i.avg > avg:
        print(i.name)
        
 Задание №2
 from collections import defaultdict
from collections import deque


def my_dex(string):
    dex = 0
    num = deque(string)
    num.reverse()
    for i in range(len(num)):
        dex += table[num[i]] * 16 ** i
    return dex


def my_hex(numb):
    num = deque()
    while numb > 0:
        d = numb % 16
        for i in table:
            if table[i] == d:
                num.append(i)
        numb //= 16
    num.reverse()
    return list(num)


signs = '0123456789ABCDEF'
table = defaultdict(int)
counter = 0
for key in signs:
    table[key] += counter
    counter += 1

num_1 = my_dex(input('Введите первое число в шестнадцатиричном формате:\n ').upper())
num_2 = my_dex(input('Введите второе число в шестнадцатиричном формате:\n ').upper())

print(f'Сумма чисел: {my_hex(num_1 + num_2)}')
print(f'Произведение чисел: {my_hex(num_1 * num_2)}')

Задание №3

from collections import deque
from timeit import timeit

normal_list = [i for i in range(10000)]
normal_deque = deque([i for i in range(10000)])
elem = 1000


def append_list(normal_list):
    for i in range(elem):
        normal_list.append(i)
    return normal_list


def append_deque(normal_deque):
    for i in range(elem):
        normal_deque.append(i)
    return normal_deque


print('Замеры функции append для list')
print(timeit('append_list(normal_list.copy())', globals=globals(), number=1000))  # 0.09573989998898469, 0.10267230001045391
print('Замеры функции append для deque')
print(timeit('append_deque(normal_deque.copy())', globals=globals(), number=1000))  # 0.1593601999920793, 0.1504166999948211
print('-' * 50)


def pop_list(normal_list):
    for i in range(elem):
        normal_list.pop()
    return normal_list


def pop_deque(normal_deque):
    for i in range(elem):
        normal_deque.pop()
    return normal_deque


print('Замеры функции pop для list')
print(timeit('pop_list(normal_list.copy())', globals=globals(), number=1000))  # 0.07415150001179427, 0.07461970002623275
print('Замеры функции pop для deque')
print(timeit('pop_deque(normal_deque.copy())', globals=globals(), number=1000))  # 0.13166610000189394, 0.13638390001142398
print('-' * 50)


def extend_list(normal_list):
    for i in range(elem):
        normal_list.extend([1, 2, 3])
    return normal_list


def extend_deque(normal_deque):
    for i in range(elem):
        normal_deque.extend([1, 2, 3])
    return normal_deque


print('Замеры функции extend для list')
print(timeit('extend_list(normal_list.copy())', globals=globals(), number=1000))  # 0.13061790002393536, 0.13864679998368956
print('Замеры функции extend для deque')
print(timeit('extend_list(normal_deque.copy())', globals=globals(), number=1000))  # 0.24488129999372177, 0.241495299997041
print('-' * 50)

'''Выводы
Функции append, рор, extend выполняется быстрее в list , чем в deque
'''

def appendleft_list(normal_list):
    for i in range(elem):
        normal_list.insert(0, i)
    return normal_list


def appendleft_deque(normal_deque):
    for i in range(elem):
        normal_deque.appendleft(i)
    return normal_deque


print('Замеры функции appendleft для list')
print(timeit('appendleft_list(normal_list.copy())', globals=globals(), number=1000))  # 4.135610800003633, 4.162483899999643
print('Замеры функции appendleft для deque')
print(timeit('appendleft_list(normal_deque.copy())', globals=globals(), number=1000))  # 0.17796959998668171, 0.1783931000099983
print('-' * 50)


def popleft_list(normal_list):
    for i in range(elem):
        normal_list.pop(i)
    return normal_list


def popleft_deque(normal_deque):
    for i in range(elem):
        normal_deque.popleft()
    return normal_deque



print('Замеры функции popleft для list')
print(timeit('popleft_list(normal_list.copy())', globals=globals(), number=1000))  # 1.6790553999890108, 1.6630890000087675
print('Замеры функции popleft для deque')
print(timeit('popleft_deque(normal_deque.copy())', globals=globals(), number=1000))  # 0.17390510000404902, 0.1395401999761816
print('-' * 50)


def extendleft_list(normal_list):
    for i in range(elem):
        normal_list.extend([1, 2, 3])
        normal_list.sort()
    return normal_list



def extendleft_deque(normal_deque):
    for i in range(elem):
        normal_deque.extendleft([1, 2, 3])
    return normal_deque


print('Замеры функции extendleft для list')
print(timeit('extendleft_list(normal_list.copy())', globals=globals(), number=100))  # 5.571673300000839, 5.770495700009633
print('Замеры функции extendleft_deque для deque')
print(timeit('extendleft_deque(normal_deque.copy())', globals=globals(), number=100))  # 0.023057799990056083, 0.023916900012409315
print('-' * 50)

'''Выводы
Все функции, которые взаимодействуют с началом массива быстрее выполняются в deque
'''

def get_element_list(normal_list):
    for i in range(elem):
        x = normal_list[i]


def get_element_deque(normal_deque):
    for i in range(elem):
        x = normal_deque[i]


print('Замеры функции get_element_list() для list')
print(timeit('get_element_list(normal_list.copy())', globals=globals(), number=1000))  # 0.06486119999317452, 0.06682249999721535
print('Замеры функции get_element_deque для deque')
print(timeit('get_element_deque(normal_deque.copy())', globals=globals(), number=1000))  # 0.13895960000809282, 0.1400761999830138
print('-' * 50)

'''Выводы
Получение элемента по индексу быстрее проходит в list, чем в deque
'''

Задание №4
from collections import OrderedDict
from timeit import timeit

ord_dict = OrderedDict([(elem,elem) for elem in list(range(1000))])
normal_dict = {elem:elem for elem in list(range(1000))}

def get_normal_dict():
    return normal_dict[500]

def get_ord_dict():
    return ord_dict[500]


print("Замеры получения элемента по индексу для normal_dict")
print(timeit("get_normal_dict()", globals=globals(), number=10000000))  # 1.0744209000004048
print("Замеры получения элемента по индексу для ord_dict")
print(timeit("get_ord_dict()", globals=globals(), number=10000000))  # 1.1036278999999922
print('-' * 50)


def del_normal_dict():
    del normal_dict[1]

def del_ord_dict():
    del ord_dict[1]


print("Замеры удаления элемента по индексу для normal_dict")
print(timeit("del_normal_dict()", globals=globals(), number=1))  # 1.2999998943996616e-06
print("Замеры удаления элемента по индексу для ord_dict")
print(timeit("del_ord_dict()", globals=globals(), number=1))  # > 1.3999997463542968e-06
print('-' * 50)

def ch_normal_dict():
    normal_dict[500] = 1

def ch_ord_dict():
    ord_dict[500] = 1


print("Замеры изменения элемента по индексу для normal_dict")
print(timeit("ch_normal_dict()", globals=globals(), number=10000000))  # 1.1898394999998345
print("Замеры изменения элемента по индексу для ord_dict")
print(timeit("ch_ord_dict()", globals=globals(), number=10000000))  # 1.5310966000006374
print('-' * 50)

"""
Выводы: Скорость выполнения операций у OrderedDict ниже чем у обычного словаря. 
Однако есть и плюсы: дополнительный метод move_to_end(), возможность добавлять 
новые атрибуты экземпляра класса ( атрибут __dict__).
"""
